"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
from documenso_sdk.models import DocumensoError
from documenso_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from documenso_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    get_discriminator,
)
from enum import Enum
import httpx
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class EnvelopeAuditLogFindOrderByColumn(str, Enum):
    CREATED_AT = "createdAt"


class EnvelopeAuditLogFindOrderByDirection(str, Enum):
    ASC = "asc"
    DESC = "desc"


class EnvelopeAuditLogFindRequestTypedDict(TypedDict):
    envelope_id: str
    r"""Envelope ID"""
    page: NotRequired[float]
    r"""The pagination page number, starts at 1."""
    per_page: NotRequired[float]
    r"""The number of items per page."""
    order_by_column: NotRequired[EnvelopeAuditLogFindOrderByColumn]
    order_by_direction: NotRequired[EnvelopeAuditLogFindOrderByDirection]


class EnvelopeAuditLogFindRequest(BaseModel):
    envelope_id: Annotated[
        str,
        pydantic.Field(alias="envelopeId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Envelope ID"""

    page: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The pagination page number, starts at 1."""

    per_page: Annotated[
        Optional[float],
        pydantic.Field(alias="perPage"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The number of items per page."""

    order_by_column: Annotated[
        Optional[EnvelopeAuditLogFindOrderByColumn],
        pydantic.Field(alias="orderByColumn"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    order_by_direction: Annotated[
        Optional[EnvelopeAuditLogFindOrderByDirection],
        pydantic.Field(alias="orderByDirection"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None


class EnvelopeAuditLogFindInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class EnvelopeAuditLogFindInternalServerErrorIssue(BaseModel):
    message: str


class EnvelopeAuditLogFindInternalServerErrorData(BaseModel):
    message: str
    code: str
    issues: Optional[List[EnvelopeAuditLogFindInternalServerErrorIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeAuditLogFindInternalServerError(DocumensoError):
    r"""Internal server error"""

    data: EnvelopeAuditLogFindInternalServerErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeAuditLogFindInternalServerErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeAuditLogFindNotFoundIssueTypedDict(TypedDict):
    message: str


class EnvelopeAuditLogFindNotFoundIssue(BaseModel):
    message: str


class EnvelopeAuditLogFindNotFoundErrorData(BaseModel):
    message: str
    code: str
    issues: Optional[List[EnvelopeAuditLogFindNotFoundIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeAuditLogFindNotFoundError(DocumensoError):
    r"""Not found"""

    data: EnvelopeAuditLogFindNotFoundErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeAuditLogFindNotFoundErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeAuditLogFindForbiddenIssueTypedDict(TypedDict):
    message: str


class EnvelopeAuditLogFindForbiddenIssue(BaseModel):
    message: str


class EnvelopeAuditLogFindForbiddenErrorData(BaseModel):
    message: str
    code: str
    issues: Optional[List[EnvelopeAuditLogFindForbiddenIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeAuditLogFindForbiddenError(DocumensoError):
    r"""Insufficient access"""

    data: EnvelopeAuditLogFindForbiddenErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeAuditLogFindForbiddenErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeAuditLogFindUnauthorizedIssueTypedDict(TypedDict):
    message: str


class EnvelopeAuditLogFindUnauthorizedIssue(BaseModel):
    message: str


class EnvelopeAuditLogFindUnauthorizedErrorData(BaseModel):
    message: str
    code: str
    issues: Optional[List[EnvelopeAuditLogFindUnauthorizedIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeAuditLogFindUnauthorizedError(DocumensoError):
    r"""Authorization not provided"""

    data: EnvelopeAuditLogFindUnauthorizedErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeAuditLogFindUnauthorizedErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeAuditLogFindBadRequestIssueTypedDict(TypedDict):
    message: str


class EnvelopeAuditLogFindBadRequestIssue(BaseModel):
    message: str


class EnvelopeAuditLogFindBadRequestErrorData(BaseModel):
    message: str
    code: str
    issues: Optional[List[EnvelopeAuditLogFindBadRequestIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeAuditLogFindBadRequestError(DocumensoError):
    r"""Invalid input data"""

    data: EnvelopeAuditLogFindBadRequestErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeAuditLogFindBadRequestErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class TypeRecipientDeleted(str, Enum):
    RECIPIENT_DELETED = "RECIPIENT_DELETED"


class EnvelopeAuditLogFindData32TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str


class EnvelopeAuditLogFindData32(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]


class DataRecipientDeletedTypedDict(TypedDict):
    type: TypeRecipientDeleted
    data: EnvelopeAuditLogFindData32TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataRecipientDeleted(BaseModel):
    type: TypeRecipientDeleted

    data: EnvelopeAuditLogFindData32

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeRecipientUpdated(str, Enum):
    RECIPIENT_UPDATED = "RECIPIENT_UPDATED"


ChangeFromUnion5TypedDict = TypeAliasType(
    "ChangeFromUnion5TypedDict", Union[str, List[str]]
)


ChangeFromUnion5 = TypeAliasType("ChangeFromUnion5", Union[str, List[str]])


ChangeToUnion5TypedDict = TypeAliasType(
    "ChangeToUnion5TypedDict", Union[str, List[str]]
)


ChangeToUnion5 = TypeAliasType("ChangeToUnion5", Union[str, List[str]])


class ChangeTypeEmail(str, Enum):
    EMAIL = "EMAIL"


class ChangeEmailTypedDict(TypedDict):
    from_: Nullable[ChangeFromUnion5TypedDict]
    to: Nullable[ChangeToUnion5TypedDict]
    type: ChangeTypeEmail


class ChangeEmail(BaseModel):
    from_: Annotated[Nullable[ChangeFromUnion5], pydantic.Field(alias="from")]

    to: Nullable[ChangeToUnion5]

    type: ChangeTypeEmail

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ChangeFromUnion4TypedDict = TypeAliasType(
    "ChangeFromUnion4TypedDict", Union[str, List[str]]
)


ChangeFromUnion4 = TypeAliasType("ChangeFromUnion4", Union[str, List[str]])


ChangeToUnion4TypedDict = TypeAliasType(
    "ChangeToUnion4TypedDict", Union[str, List[str]]
)


ChangeToUnion4 = TypeAliasType("ChangeToUnion4", Union[str, List[str]])


class TypeRole(str, Enum):
    ROLE = "ROLE"


class ChangeRoleTypedDict(TypedDict):
    from_: Nullable[ChangeFromUnion4TypedDict]
    to: Nullable[ChangeToUnion4TypedDict]
    type: TypeRole


class ChangeRole(BaseModel):
    from_: Annotated[Nullable[ChangeFromUnion4], pydantic.Field(alias="from")]

    to: Nullable[ChangeToUnion4]

    type: TypeRole

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ChangeFromUnion3TypedDict = TypeAliasType(
    "ChangeFromUnion3TypedDict", Union[str, List[str]]
)


ChangeFromUnion3 = TypeAliasType("ChangeFromUnion3", Union[str, List[str]])


ChangeToUnion3TypedDict = TypeAliasType(
    "ChangeToUnion3TypedDict", Union[str, List[str]]
)


ChangeToUnion3 = TypeAliasType("ChangeToUnion3", Union[str, List[str]])


class ChangeTypeName(str, Enum):
    NAME = "NAME"


class ChangeNameTypedDict(TypedDict):
    from_: Nullable[ChangeFromUnion3TypedDict]
    to: Nullable[ChangeToUnion3TypedDict]
    type: ChangeTypeName


class ChangeName(BaseModel):
    from_: Annotated[Nullable[ChangeFromUnion3], pydantic.Field(alias="from")]

    to: Nullable[ChangeToUnion3]

    type: ChangeTypeName

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ChangeFromUnion2TypedDict = TypeAliasType(
    "ChangeFromUnion2TypedDict", Union[str, List[str]]
)


ChangeFromUnion2 = TypeAliasType("ChangeFromUnion2", Union[str, List[str]])


ChangeToUnion2TypedDict = TypeAliasType(
    "ChangeToUnion2TypedDict", Union[str, List[str]]
)


ChangeToUnion2 = TypeAliasType("ChangeToUnion2", Union[str, List[str]])


class TypeAccessAuth(str, Enum):
    ACCESS_AUTH = "ACCESS_AUTH"


class ChangeAccessAuthTypedDict(TypedDict):
    from_: Nullable[ChangeFromUnion2TypedDict]
    to: Nullable[ChangeToUnion2TypedDict]
    type: TypeAccessAuth


class ChangeAccessAuth(BaseModel):
    from_: Annotated[Nullable[ChangeFromUnion2], pydantic.Field(alias="from")]

    to: Nullable[ChangeToUnion2]

    type: TypeAccessAuth

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ChangeFromUnion1TypedDict = TypeAliasType(
    "ChangeFromUnion1TypedDict", Union[str, List[str]]
)


ChangeFromUnion1 = TypeAliasType("ChangeFromUnion1", Union[str, List[str]])


ChangeToUnion1TypedDict = TypeAliasType(
    "ChangeToUnion1TypedDict", Union[str, List[str]]
)


ChangeToUnion1 = TypeAliasType("ChangeToUnion1", Union[str, List[str]])


class TypeActionAuth(str, Enum):
    ACTION_AUTH = "ACTION_AUTH"


class ChangeActionAuthTypedDict(TypedDict):
    from_: Nullable[ChangeFromUnion1TypedDict]
    to: Nullable[ChangeToUnion1TypedDict]
    type: TypeActionAuth


class ChangeActionAuth(BaseModel):
    from_: Annotated[Nullable[ChangeFromUnion1], pydantic.Field(alias="from")]

    to: Nullable[ChangeToUnion1]

    type: TypeActionAuth

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ChangeUnion3TypedDict = TypeAliasType(
    "ChangeUnion3TypedDict",
    Union[
        ChangeActionAuthTypedDict,
        ChangeAccessAuthTypedDict,
        ChangeNameTypedDict,
        ChangeRoleTypedDict,
        ChangeEmailTypedDict,
    ],
)


ChangeUnion3 = Annotated[
    Union[
        Annotated[ChangeActionAuth, Tag("ACTION_AUTH")],
        Annotated[ChangeAccessAuth, Tag("ACCESS_AUTH")],
        Annotated[ChangeName, Tag("NAME")],
        Annotated[ChangeRole, Tag("ROLE")],
        Annotated[ChangeEmail, Tag("EMAIL")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class EnvelopeAuditLogFindData31TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    changes: List[ChangeUnion3TypedDict]


class EnvelopeAuditLogFindData31(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    changes: List[ChangeUnion3]


class DataRecipientUpdatedTypedDict(TypedDict):
    type: TypeRecipientUpdated
    data: EnvelopeAuditLogFindData31TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataRecipientUpdated(BaseModel):
    type: TypeRecipientUpdated

    data: EnvelopeAuditLogFindData31

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeRecipientCreated(str, Enum):
    RECIPIENT_CREATED = "RECIPIENT_CREATED"


class EnvelopeAuditLogFindAccessAuth3(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class EnvelopeAuditLogFindActionAuth2(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class EnvelopeAuditLogFindData30TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    access_auth: List[EnvelopeAuditLogFindAccessAuth3]
    action_auth: List[EnvelopeAuditLogFindActionAuth2]


class EnvelopeAuditLogFindData30(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    access_auth: Annotated[
        List[EnvelopeAuditLogFindAccessAuth3], pydantic.Field(alias="accessAuth")
    ]

    action_auth: Annotated[
        List[EnvelopeAuditLogFindActionAuth2], pydantic.Field(alias="actionAuth")
    ]


class DataRecipientCreatedTypedDict(TypedDict):
    type: TypeRecipientCreated
    data: EnvelopeAuditLogFindData30TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataRecipientCreated(BaseModel):
    type: TypeRecipientCreated

    data: EnvelopeAuditLogFindData30

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeFieldUpdated(str, Enum):
    FIELD_UPDATED = "FIELD_UPDATED"


class TypePosition(str, Enum):
    POSITION = "POSITION"


class ChangeFrom2TypedDict(TypedDict):
    page: float
    position_x: float
    position_y: float


class ChangeFrom2(BaseModel):
    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]


class ChangeTo2TypedDict(TypedDict):
    page: float
    position_x: float
    position_y: float


class ChangeTo2(BaseModel):
    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]


class ChangePositionTypedDict(TypedDict):
    type: TypePosition
    from_: ChangeFrom2TypedDict
    to: ChangeTo2TypedDict


class ChangePosition(BaseModel):
    type: TypePosition

    from_: Annotated[ChangeFrom2, pydantic.Field(alias="from")]

    to: ChangeTo2


class TypeDimension(str, Enum):
    DIMENSION = "DIMENSION"


class ChangeFrom1TypedDict(TypedDict):
    width: float
    height: float


class ChangeFrom1(BaseModel):
    width: float

    height: float


class ChangeTo1TypedDict(TypedDict):
    width: float
    height: float


class ChangeTo1(BaseModel):
    width: float

    height: float


class ChangeDimensionTypedDict(TypedDict):
    type: TypeDimension
    from_: ChangeFrom1TypedDict
    to: ChangeTo1TypedDict


class ChangeDimension(BaseModel):
    type: TypeDimension

    from_: Annotated[ChangeFrom1, pydantic.Field(alias="from")]

    to: ChangeTo1


ChangeUnion2TypedDict = TypeAliasType(
    "ChangeUnion2TypedDict", Union[ChangeDimensionTypedDict, ChangePositionTypedDict]
)


ChangeUnion2 = Annotated[
    Union[
        Annotated[ChangeDimension, Tag("DIMENSION")],
        Annotated[ChangePosition, Tag("POSITION")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class EnvelopeAuditLogFindData29TypedDict(TypedDict):
    field_id: str
    field_recipient_email: str
    field_recipient_id: float
    field_type: str
    changes: List[ChangeUnion2TypedDict]


class EnvelopeAuditLogFindData29(BaseModel):
    field_id: Annotated[str, pydantic.Field(alias="fieldId")]

    field_recipient_email: Annotated[str, pydantic.Field(alias="fieldRecipientEmail")]

    field_recipient_id: Annotated[float, pydantic.Field(alias="fieldRecipientId")]

    field_type: Annotated[str, pydantic.Field(alias="fieldType")]

    changes: List[ChangeUnion2]


class DataFieldUpdatedTypedDict(TypedDict):
    type: TypeFieldUpdated
    data: EnvelopeAuditLogFindData29TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataFieldUpdated(BaseModel):
    type: TypeFieldUpdated

    data: EnvelopeAuditLogFindData29

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeFieldDeleted(str, Enum):
    FIELD_DELETED = "FIELD_DELETED"


class EnvelopeAuditLogFindData28TypedDict(TypedDict):
    field_id: str
    field_recipient_email: str
    field_recipient_id: float
    field_type: str


class EnvelopeAuditLogFindData28(BaseModel):
    field_id: Annotated[str, pydantic.Field(alias="fieldId")]

    field_recipient_email: Annotated[str, pydantic.Field(alias="fieldRecipientEmail")]

    field_recipient_id: Annotated[float, pydantic.Field(alias="fieldRecipientId")]

    field_type: Annotated[str, pydantic.Field(alias="fieldType")]


class DataFieldDeletedTypedDict(TypedDict):
    type: TypeFieldDeleted
    data: EnvelopeAuditLogFindData28TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataFieldDeleted(BaseModel):
    type: TypeFieldDeleted

    data: EnvelopeAuditLogFindData28

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeFieldCreated(str, Enum):
    FIELD_CREATED = "FIELD_CREATED"


class EnvelopeAuditLogFindData27TypedDict(TypedDict):
    field_id: str
    field_recipient_email: str
    field_recipient_id: float
    field_type: str


class EnvelopeAuditLogFindData27(BaseModel):
    field_id: Annotated[str, pydantic.Field(alias="fieldId")]

    field_recipient_email: Annotated[str, pydantic.Field(alias="fieldRecipientEmail")]

    field_recipient_id: Annotated[float, pydantic.Field(alias="fieldRecipientId")]

    field_type: Annotated[str, pydantic.Field(alias="fieldType")]


class DataFieldCreatedTypedDict(TypedDict):
    type: TypeFieldCreated
    data: EnvelopeAuditLogFindData27TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataFieldCreated(BaseModel):
    type: TypeFieldCreated

    data: EnvelopeAuditLogFindData27

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentExternalIDUpdated(str, Enum):
    DOCUMENT_EXTERNAL_ID_UPDATED = "DOCUMENT_EXTERNAL_ID_UPDATED"


class EnvelopeAuditLogFindData26TypedDict(TypedDict):
    from_: NotRequired[Nullable[str]]
    to: NotRequired[Nullable[str]]


class EnvelopeAuditLogFindData26(BaseModel):
    from_: Annotated[OptionalNullable[str], pydantic.Field(alias="from")] = UNSET

    to: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["from", "to"]
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DataDocumentExternalIDUpdatedTypedDict(TypedDict):
    type: TypeDocumentExternalIDUpdated
    data: EnvelopeAuditLogFindData26TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentExternalIDUpdated(BaseModel):
    type: TypeDocumentExternalIDUpdated

    data: EnvelopeAuditLogFindData26

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentTitleUpdated(str, Enum):
    DOCUMENT_TITLE_UPDATED = "DOCUMENT_TITLE_UPDATED"


class EnvelopeAuditLogFindData25TypedDict(TypedDict):
    from_: str
    to: str


class EnvelopeAuditLogFindData25(BaseModel):
    from_: Annotated[str, pydantic.Field(alias="from")]

    to: str


class DataDocumentTitleUpdatedTypedDict(TypedDict):
    type: TypeDocumentTitleUpdated
    data: EnvelopeAuditLogFindData25TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentTitleUpdated(BaseModel):
    type: TypeDocumentTitleUpdated

    data: EnvelopeAuditLogFindData25

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentSent(str, Enum):
    DOCUMENT_SENT = "DOCUMENT_SENT"


class EnvelopeAuditLogFindData24TypedDict(TypedDict):
    pass


class EnvelopeAuditLogFindData24(BaseModel):
    pass


class DataDocumentSentTypedDict(TypedDict):
    type: TypeDocumentSent
    data: EnvelopeAuditLogFindData24TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentSent(BaseModel):
    type: TypeDocumentSent

    data: EnvelopeAuditLogFindData24

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentAccessAuth2FaFailed(str, Enum):
    DOCUMENT_ACCESS_AUTH_2_FA_FAILED = "DOCUMENT_ACCESS_AUTH_2FA_FAILED"


class EnvelopeAuditLogFindData23TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float


class EnvelopeAuditLogFindData23(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]


class DataDocumentAccessAuth2FaFailedTypedDict(TypedDict):
    type: TypeDocumentAccessAuth2FaFailed
    data: EnvelopeAuditLogFindData23TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentAccessAuth2FaFailed(BaseModel):
    type: TypeDocumentAccessAuth2FaFailed

    data: EnvelopeAuditLogFindData23

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentAccessAuth2FaValidated(str, Enum):
    DOCUMENT_ACCESS_AUTH_2_FA_VALIDATED = "DOCUMENT_ACCESS_AUTH_2FA_VALIDATED"


class EnvelopeAuditLogFindData22TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float


class EnvelopeAuditLogFindData22(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]


class DataDocumentAccessAuth2FaValidatedTypedDict(TypedDict):
    type: TypeDocumentAccessAuth2FaValidated
    data: EnvelopeAuditLogFindData22TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentAccessAuth2FaValidated(BaseModel):
    type: TypeDocumentAccessAuth2FaValidated

    data: EnvelopeAuditLogFindData22

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentAccessAuth2FaRequested(str, Enum):
    DOCUMENT_ACCESS_AUTH_2_FA_REQUESTED = "DOCUMENT_ACCESS_AUTH_2FA_REQUESTED"


class EnvelopeAuditLogFindData21TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float


class EnvelopeAuditLogFindData21(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]


class DataDocumentAccessAuth2FaRequestedTypedDict(TypedDict):
    type: TypeDocumentAccessAuth2FaRequested
    data: EnvelopeAuditLogFindData21TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentAccessAuth2FaRequested(BaseModel):
    type: TypeDocumentAccessAuth2FaRequested

    data: EnvelopeAuditLogFindData21

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentRecipientRejected(str, Enum):
    DOCUMENT_RECIPIENT_REJECTED = "DOCUMENT_RECIPIENT_REJECTED"


class EnvelopeAuditLogFindData20TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    reason: str


class EnvelopeAuditLogFindData20(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    reason: str


class DataDocumentRecipientRejectedTypedDict(TypedDict):
    type: TypeDocumentRecipientRejected
    data: EnvelopeAuditLogFindData20TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentRecipientRejected(BaseModel):
    type: TypeDocumentRecipientRejected

    data: EnvelopeAuditLogFindData20

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentRecipientCompleted(str, Enum):
    DOCUMENT_RECIPIENT_COMPLETED = "DOCUMENT_RECIPIENT_COMPLETED"


class EnvelopeAuditLogFindActionAuth1(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class EnvelopeAuditLogFindData19TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    action_auth: List[EnvelopeAuditLogFindActionAuth1]


class EnvelopeAuditLogFindData19(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    action_auth: Annotated[
        List[EnvelopeAuditLogFindActionAuth1], pydantic.Field(alias="actionAuth")
    ]


class DataDocumentRecipientCompletedTypedDict(TypedDict):
    type: TypeDocumentRecipientCompleted
    data: EnvelopeAuditLogFindData19TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentRecipientCompleted(BaseModel):
    type: TypeDocumentRecipientCompleted

    data: EnvelopeAuditLogFindData19

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentViewed(str, Enum):
    DOCUMENT_VIEWED = "DOCUMENT_VIEWED"


class EnvelopeAuditLogFindAccessAuth2(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class EnvelopeAuditLogFindData18TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    access_auth: List[EnvelopeAuditLogFindAccessAuth2]


class EnvelopeAuditLogFindData18(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    access_auth: Annotated[
        List[EnvelopeAuditLogFindAccessAuth2], pydantic.Field(alias="accessAuth")
    ]


class DataDocumentViewedTypedDict(TypedDict):
    type: TypeDocumentViewed
    data: EnvelopeAuditLogFindData18TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentViewed(BaseModel):
    type: TypeDocumentViewed

    data: EnvelopeAuditLogFindData18

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentOpened(str, Enum):
    DOCUMENT_OPENED = "DOCUMENT_OPENED"


class EnvelopeAuditLogFindAccessAuth1(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class EnvelopeAuditLogFindData17TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    access_auth: List[EnvelopeAuditLogFindAccessAuth1]


class EnvelopeAuditLogFindData17(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    access_auth: Annotated[
        List[EnvelopeAuditLogFindAccessAuth1], pydantic.Field(alias="accessAuth")
    ]


class DataDocumentOpenedTypedDict(TypedDict):
    type: TypeDocumentOpened
    data: EnvelopeAuditLogFindData17TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentOpened(BaseModel):
    type: TypeDocumentOpened

    data: EnvelopeAuditLogFindData17

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentMetaUpdated(str, Enum):
    DOCUMENT_META_UPDATED = "DOCUMENT_META_UPDATED"


class TypePassword(str, Enum):
    PASSWORD = "PASSWORD"


class ChangePasswordTypedDict(TypedDict):
    type: TypePassword


class ChangePassword(BaseModel):
    type: TypePassword


class TypeEmailSettings(str, Enum):
    EMAIL_SETTINGS = "EMAIL_SETTINGS"


class TypeEmailReplyTo(str, Enum):
    EMAIL_REPLY_TO = "EMAIL_REPLY_TO"


class TypeEmailID(str, Enum):
    EMAIL_ID = "EMAIL_ID"


class TypeTimezone(str, Enum):
    TIMEZONE = "TIMEZONE"


class TypeSubject(str, Enum):
    SUBJECT = "SUBJECT"


class TypeRedirectURL(str, Enum):
    REDIRECT_URL = "REDIRECT_URL"


class TypeMessage(str, Enum):
    MESSAGE = "MESSAGE"


class TypeDateFormat(str, Enum):
    DATE_FORMAT = "DATE_FORMAT"


ChangeTypeUnionTypedDict = TypeAliasType(
    "ChangeTypeUnionTypedDict",
    Union[
        TypeDateFormat,
        TypeMessage,
        TypeRedirectURL,
        TypeSubject,
        TypeTimezone,
        TypeEmailID,
        TypeEmailReplyTo,
        TypeEmailSettings,
    ],
)


ChangeTypeUnion = TypeAliasType(
    "ChangeTypeUnion",
    Union[
        TypeDateFormat,
        TypeMessage,
        TypeRedirectURL,
        TypeSubject,
        TypeTimezone,
        TypeEmailID,
        TypeEmailReplyTo,
        TypeEmailSettings,
    ],
)


class ChangeTypedDict(TypedDict):
    type: ChangeTypeUnionTypedDict
    from_: Nullable[str]
    to: Nullable[str]


class Change(BaseModel):
    type: ChangeTypeUnion

    from_: Annotated[Nullable[str], pydantic.Field(alias="from")]

    to: Nullable[str]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ChangeUnion1TypedDict = TypeAliasType(
    "ChangeUnion1TypedDict", Union[ChangePasswordTypedDict, ChangeTypedDict]
)


ChangeUnion1 = TypeAliasType("ChangeUnion1", Union[ChangePassword, Change])


class EnvelopeAuditLogFindData16TypedDict(TypedDict):
    changes: List[ChangeUnion1TypedDict]


class EnvelopeAuditLogFindData16(BaseModel):
    changes: List[ChangeUnion1]


class DataDocumentMetaUpdatedTypedDict(TypedDict):
    type: TypeDocumentMetaUpdated
    data: EnvelopeAuditLogFindData16TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentMetaUpdated(BaseModel):
    type: TypeDocumentMetaUpdated

    data: EnvelopeAuditLogFindData16

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentGlobalAuthActionUpdated(str, Enum):
    DOCUMENT_GLOBAL_AUTH_ACTION_UPDATED = "DOCUMENT_GLOBAL_AUTH_ACTION_UPDATED"


FromUnion3TypedDict = TypeAliasType("FromUnion3TypedDict", Union[str, List[str]])


FromUnion3 = TypeAliasType("FromUnion3", Union[str, List[str]])


ToUnion3TypedDict = TypeAliasType("ToUnion3TypedDict", Union[str, List[str]])


ToUnion3 = TypeAliasType("ToUnion3", Union[str, List[str]])


class EnvelopeAuditLogFindData15TypedDict(TypedDict):
    from_: Nullable[FromUnion3TypedDict]
    to: Nullable[ToUnion3TypedDict]


class EnvelopeAuditLogFindData15(BaseModel):
    from_: Annotated[Nullable[FromUnion3], pydantic.Field(alias="from")]

    to: Nullable[ToUnion3]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DataDocumentGlobalAuthActionUpdatedTypedDict(TypedDict):
    type: TypeDocumentGlobalAuthActionUpdated
    data: EnvelopeAuditLogFindData15TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentGlobalAuthActionUpdated(BaseModel):
    type: TypeDocumentGlobalAuthActionUpdated

    data: EnvelopeAuditLogFindData15

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentGlobalAuthAccessUpdated(str, Enum):
    DOCUMENT_GLOBAL_AUTH_ACCESS_UPDATED = "DOCUMENT_GLOBAL_AUTH_ACCESS_UPDATED"


FromUnion2TypedDict = TypeAliasType("FromUnion2TypedDict", Union[str, List[str]])


FromUnion2 = TypeAliasType("FromUnion2", Union[str, List[str]])


ToUnion2TypedDict = TypeAliasType("ToUnion2TypedDict", Union[str, List[str]])


ToUnion2 = TypeAliasType("ToUnion2", Union[str, List[str]])


class EnvelopeAuditLogFindData14TypedDict(TypedDict):
    from_: Nullable[FromUnion2TypedDict]
    to: Nullable[ToUnion2TypedDict]


class EnvelopeAuditLogFindData14(BaseModel):
    from_: Annotated[Nullable[FromUnion2], pydantic.Field(alias="from")]

    to: Nullable[ToUnion2]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DataDocumentGlobalAuthAccessUpdatedTypedDict(TypedDict):
    type: TypeDocumentGlobalAuthAccessUpdated
    data: EnvelopeAuditLogFindData14TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentGlobalAuthAccessUpdated(BaseModel):
    type: TypeDocumentGlobalAuthAccessUpdated

    data: EnvelopeAuditLogFindData14

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentVisibilityUpdated(str, Enum):
    DOCUMENT_VISIBILITY_UPDATED = "DOCUMENT_VISIBILITY_UPDATED"


FromUnion1TypedDict = TypeAliasType("FromUnion1TypedDict", Union[str, List[str]])


FromUnion1 = TypeAliasType("FromUnion1", Union[str, List[str]])


ToUnion1TypedDict = TypeAliasType("ToUnion1TypedDict", Union[str, List[str]])


ToUnion1 = TypeAliasType("ToUnion1", Union[str, List[str]])


class EnvelopeAuditLogFindData13TypedDict(TypedDict):
    from_: Nullable[FromUnion1TypedDict]
    to: Nullable[ToUnion1TypedDict]


class EnvelopeAuditLogFindData13(BaseModel):
    from_: Annotated[Nullable[FromUnion1], pydantic.Field(alias="from")]

    to: Nullable[ToUnion1]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["from", "to"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DataDocumentVisibilityUpdatedTypedDict(TypedDict):
    type: TypeDocumentVisibilityUpdated
    data: EnvelopeAuditLogFindData13TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentVisibilityUpdated(BaseModel):
    type: TypeDocumentVisibilityUpdated

    data: EnvelopeAuditLogFindData13

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentFieldPrefilled(str, Enum):
    DOCUMENT_FIELD_PREFILLED = "DOCUMENT_FIELD_PREFILLED"


class EnvelopeAuditLogFindTypeNumber2(str, Enum):
    NUMBER = "NUMBER"


class EnvelopeAuditLogFindFieldNumber2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeNumber2
    data: str


class EnvelopeAuditLogFindFieldNumber2(BaseModel):
    type: EnvelopeAuditLogFindTypeNumber2

    data: str


class EnvelopeAuditLogFindTypeDropdown2(str, Enum):
    DROPDOWN = "DROPDOWN"


class EnvelopeAuditLogFindFieldDropdown2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeDropdown2
    data: str


class EnvelopeAuditLogFindFieldDropdown2(BaseModel):
    type: EnvelopeAuditLogFindTypeDropdown2

    data: str


class EnvelopeAuditLogFindTypeCheckbox2(str, Enum):
    CHECKBOX = "CHECKBOX"


class EnvelopeAuditLogFindFieldCheckbox2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeCheckbox2
    data: str


class EnvelopeAuditLogFindFieldCheckbox2(BaseModel):
    type: EnvelopeAuditLogFindTypeCheckbox2

    data: str


class EnvelopeAuditLogFindTypeRadio2(str, Enum):
    RADIO = "RADIO"


class EnvelopeAuditLogFindFieldRadio2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeRadio2
    data: str


class EnvelopeAuditLogFindFieldRadio2(BaseModel):
    type: EnvelopeAuditLogFindTypeRadio2

    data: str


class EnvelopeAuditLogFindTypeFreeSignature2(str, Enum):
    FREE_SIGNATURE = "FREE_SIGNATURE"


class EnvelopeAuditLogFindTypeSignature2(str, Enum):
    SIGNATURE = "SIGNATURE"


FieldTypeUnion2TypedDict = TypeAliasType(
    "FieldTypeUnion2TypedDict",
    Union[EnvelopeAuditLogFindTypeSignature2, EnvelopeAuditLogFindTypeFreeSignature2],
)


FieldTypeUnion2 = TypeAliasType(
    "FieldTypeUnion2",
    Union[EnvelopeAuditLogFindTypeSignature2, EnvelopeAuditLogFindTypeFreeSignature2],
)


class EnvelopeAuditLogFindField3TypedDict(TypedDict):
    type: FieldTypeUnion2TypedDict
    data: str


class EnvelopeAuditLogFindField3(BaseModel):
    type: FieldTypeUnion2

    data: str


class EnvelopeAuditLogFindTypeText2(str, Enum):
    TEXT = "TEXT"


class EnvelopeAuditLogFindFieldText2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeText2
    data: str


class EnvelopeAuditLogFindFieldText2(BaseModel):
    type: EnvelopeAuditLogFindTypeText2

    data: str


class EnvelopeAuditLogFindFieldTypeName2(str, Enum):
    NAME = "NAME"


class EnvelopeAuditLogFindFieldName2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindFieldTypeName2
    data: str


class EnvelopeAuditLogFindFieldName2(BaseModel):
    type: EnvelopeAuditLogFindFieldTypeName2

    data: str


class EnvelopeAuditLogFindTypeDate2(str, Enum):
    DATE = "DATE"


class EnvelopeAuditLogFindFieldDate2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeDate2
    data: str


class EnvelopeAuditLogFindFieldDate2(BaseModel):
    type: EnvelopeAuditLogFindTypeDate2

    data: str


class EnvelopeAuditLogFindFieldTypeEmail2(str, Enum):
    EMAIL = "EMAIL"


class EnvelopeAuditLogFindFieldEmail2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindFieldTypeEmail2
    data: str


class EnvelopeAuditLogFindFieldEmail2(BaseModel):
    type: EnvelopeAuditLogFindFieldTypeEmail2

    data: str


class EnvelopeAuditLogFindTypeInitials2(str, Enum):
    INITIALS = "INITIALS"


class EnvelopeAuditLogFindFieldInitials2TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeInitials2
    data: str


class EnvelopeAuditLogFindFieldInitials2(BaseModel):
    type: EnvelopeAuditLogFindTypeInitials2

    data: str


EnvelopeAuditLogFindFieldUnion2TypedDict = TypeAliasType(
    "EnvelopeAuditLogFindFieldUnion2TypedDict",
    Union[
        EnvelopeAuditLogFindFieldInitials2TypedDict,
        EnvelopeAuditLogFindFieldEmail2TypedDict,
        EnvelopeAuditLogFindFieldDate2TypedDict,
        EnvelopeAuditLogFindFieldName2TypedDict,
        EnvelopeAuditLogFindFieldText2TypedDict,
        EnvelopeAuditLogFindField3TypedDict,
        EnvelopeAuditLogFindFieldRadio2TypedDict,
        EnvelopeAuditLogFindFieldCheckbox2TypedDict,
        EnvelopeAuditLogFindFieldDropdown2TypedDict,
        EnvelopeAuditLogFindFieldNumber2TypedDict,
    ],
)


EnvelopeAuditLogFindFieldUnion2 = TypeAliasType(
    "EnvelopeAuditLogFindFieldUnion2",
    Union[
        EnvelopeAuditLogFindFieldInitials2,
        EnvelopeAuditLogFindFieldEmail2,
        EnvelopeAuditLogFindFieldDate2,
        EnvelopeAuditLogFindFieldName2,
        EnvelopeAuditLogFindFieldText2,
        EnvelopeAuditLogFindField3,
        EnvelopeAuditLogFindFieldRadio2,
        EnvelopeAuditLogFindFieldCheckbox2,
        EnvelopeAuditLogFindFieldDropdown2,
        EnvelopeAuditLogFindFieldNumber2,
    ],
)


class FieldSecurityType2(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class FieldSecurity2TypedDict(TypedDict):
    type: NotRequired[FieldSecurityType2]


class FieldSecurity2(BaseModel):
    type: Optional[FieldSecurityType2] = None


class EnvelopeAuditLogFindData12TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    field_id: str
    field: EnvelopeAuditLogFindFieldUnion2TypedDict
    field_security: NotRequired[FieldSecurity2TypedDict]


class EnvelopeAuditLogFindData12(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    field_id: Annotated[str, pydantic.Field(alias="fieldId")]

    field: EnvelopeAuditLogFindFieldUnion2

    field_security: Annotated[
        Optional[FieldSecurity2], pydantic.Field(alias="fieldSecurity")
    ] = None


class DataDocumentFieldPrefilledTypedDict(TypedDict):
    type: TypeDocumentFieldPrefilled
    data: EnvelopeAuditLogFindData12TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentFieldPrefilled(BaseModel):
    type: TypeDocumentFieldPrefilled

    data: EnvelopeAuditLogFindData12

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentFieldUninserted(str, Enum):
    DOCUMENT_FIELD_UNINSERTED = "DOCUMENT_FIELD_UNINSERTED"


class FieldEnum(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class EnvelopeAuditLogFindData11TypedDict(TypedDict):
    field: FieldEnum
    field_id: str


class EnvelopeAuditLogFindData11(BaseModel):
    field: FieldEnum

    field_id: Annotated[str, pydantic.Field(alias="fieldId")]


class DataDocumentFieldUninsertedTypedDict(TypedDict):
    type: TypeDocumentFieldUninserted
    data: EnvelopeAuditLogFindData11TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentFieldUninserted(BaseModel):
    type: TypeDocumentFieldUninserted

    data: EnvelopeAuditLogFindData11

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentFieldInserted(str, Enum):
    DOCUMENT_FIELD_INSERTED = "DOCUMENT_FIELD_INSERTED"


class EnvelopeAuditLogFindTypeNumber1(str, Enum):
    NUMBER = "NUMBER"


class EnvelopeAuditLogFindFieldNumber1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeNumber1
    data: str


class EnvelopeAuditLogFindFieldNumber1(BaseModel):
    type: EnvelopeAuditLogFindTypeNumber1

    data: str


class EnvelopeAuditLogFindTypeDropdown1(str, Enum):
    DROPDOWN = "DROPDOWN"


class EnvelopeAuditLogFindFieldDropdown1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeDropdown1
    data: str


class EnvelopeAuditLogFindFieldDropdown1(BaseModel):
    type: EnvelopeAuditLogFindTypeDropdown1

    data: str


class EnvelopeAuditLogFindTypeCheckbox1(str, Enum):
    CHECKBOX = "CHECKBOX"


class EnvelopeAuditLogFindFieldCheckbox1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeCheckbox1
    data: str


class EnvelopeAuditLogFindFieldCheckbox1(BaseModel):
    type: EnvelopeAuditLogFindTypeCheckbox1

    data: str


class EnvelopeAuditLogFindTypeRadio1(str, Enum):
    RADIO = "RADIO"


class EnvelopeAuditLogFindFieldRadio1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeRadio1
    data: str


class EnvelopeAuditLogFindFieldRadio1(BaseModel):
    type: EnvelopeAuditLogFindTypeRadio1

    data: str


class EnvelopeAuditLogFindTypeFreeSignature1(str, Enum):
    FREE_SIGNATURE = "FREE_SIGNATURE"


class EnvelopeAuditLogFindTypeSignature1(str, Enum):
    SIGNATURE = "SIGNATURE"


FieldTypeUnion1TypedDict = TypeAliasType(
    "FieldTypeUnion1TypedDict",
    Union[EnvelopeAuditLogFindTypeSignature1, EnvelopeAuditLogFindTypeFreeSignature1],
)


FieldTypeUnion1 = TypeAliasType(
    "FieldTypeUnion1",
    Union[EnvelopeAuditLogFindTypeSignature1, EnvelopeAuditLogFindTypeFreeSignature1],
)


class EnvelopeAuditLogFindField2TypedDict(TypedDict):
    type: FieldTypeUnion1TypedDict
    data: str


class EnvelopeAuditLogFindField2(BaseModel):
    type: FieldTypeUnion1

    data: str


class EnvelopeAuditLogFindTypeText1(str, Enum):
    TEXT = "TEXT"


class EnvelopeAuditLogFindFieldText1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeText1
    data: str


class EnvelopeAuditLogFindFieldText1(BaseModel):
    type: EnvelopeAuditLogFindTypeText1

    data: str


class EnvelopeAuditLogFindFieldTypeName1(str, Enum):
    NAME = "NAME"


class EnvelopeAuditLogFindFieldName1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindFieldTypeName1
    data: str


class EnvelopeAuditLogFindFieldName1(BaseModel):
    type: EnvelopeAuditLogFindFieldTypeName1

    data: str


class EnvelopeAuditLogFindTypeDate1(str, Enum):
    DATE = "DATE"


class EnvelopeAuditLogFindFieldDate1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeDate1
    data: str


class EnvelopeAuditLogFindFieldDate1(BaseModel):
    type: EnvelopeAuditLogFindTypeDate1

    data: str


class EnvelopeAuditLogFindFieldTypeEmail1(str, Enum):
    EMAIL = "EMAIL"


class EnvelopeAuditLogFindFieldEmail1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindFieldTypeEmail1
    data: str


class EnvelopeAuditLogFindFieldEmail1(BaseModel):
    type: EnvelopeAuditLogFindFieldTypeEmail1

    data: str


class EnvelopeAuditLogFindTypeInitials1(str, Enum):
    INITIALS = "INITIALS"


class EnvelopeAuditLogFindFieldInitials1TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeInitials1
    data: str


class EnvelopeAuditLogFindFieldInitials1(BaseModel):
    type: EnvelopeAuditLogFindTypeInitials1

    data: str


EnvelopeAuditLogFindFieldUnion1TypedDict = TypeAliasType(
    "EnvelopeAuditLogFindFieldUnion1TypedDict",
    Union[
        EnvelopeAuditLogFindFieldInitials1TypedDict,
        EnvelopeAuditLogFindFieldEmail1TypedDict,
        EnvelopeAuditLogFindFieldDate1TypedDict,
        EnvelopeAuditLogFindFieldName1TypedDict,
        EnvelopeAuditLogFindFieldText1TypedDict,
        EnvelopeAuditLogFindField2TypedDict,
        EnvelopeAuditLogFindFieldRadio1TypedDict,
        EnvelopeAuditLogFindFieldCheckbox1TypedDict,
        EnvelopeAuditLogFindFieldDropdown1TypedDict,
        EnvelopeAuditLogFindFieldNumber1TypedDict,
    ],
)


EnvelopeAuditLogFindFieldUnion1 = TypeAliasType(
    "EnvelopeAuditLogFindFieldUnion1",
    Union[
        EnvelopeAuditLogFindFieldInitials1,
        EnvelopeAuditLogFindFieldEmail1,
        EnvelopeAuditLogFindFieldDate1,
        EnvelopeAuditLogFindFieldName1,
        EnvelopeAuditLogFindFieldText1,
        EnvelopeAuditLogFindField2,
        EnvelopeAuditLogFindFieldRadio1,
        EnvelopeAuditLogFindFieldCheckbox1,
        EnvelopeAuditLogFindFieldDropdown1,
        EnvelopeAuditLogFindFieldNumber1,
    ],
)


class FieldSecurityType1(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class FieldSecurity1TypedDict(TypedDict):
    type: NotRequired[FieldSecurityType1]


class FieldSecurity1(BaseModel):
    type: Optional[FieldSecurityType1] = None


class EnvelopeAuditLogFindData10TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    field_id: str
    field: EnvelopeAuditLogFindFieldUnion1TypedDict
    field_security: NotRequired[FieldSecurity1TypedDict]


class EnvelopeAuditLogFindData10(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    field_id: Annotated[str, pydantic.Field(alias="fieldId")]

    field: EnvelopeAuditLogFindFieldUnion1

    field_security: Annotated[
        Optional[FieldSecurity1], pydantic.Field(alias="fieldSecurity")
    ] = None


class DataDocumentFieldInsertedTypedDict(TypedDict):
    type: TypeDocumentFieldInserted
    data: EnvelopeAuditLogFindData10TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentFieldInserted(BaseModel):
    type: TypeDocumentFieldInserted

    data: EnvelopeAuditLogFindData10

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentFieldsAutoInserted(str, Enum):
    DOCUMENT_FIELDS_AUTO_INSERTED = "DOCUMENT_FIELDS_AUTO_INSERTED"


class FieldType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class EnvelopeAuditLogFindField1TypedDict(TypedDict):
    field_id: float
    field_type: FieldType
    recipient_id: float


class EnvelopeAuditLogFindField1(BaseModel):
    field_id: Annotated[float, pydantic.Field(alias="fieldId")]

    field_type: Annotated[FieldType, pydantic.Field(alias="fieldType")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]


class EnvelopeAuditLogFindData9TypedDict(TypedDict):
    fields: List[EnvelopeAuditLogFindField1TypedDict]


class EnvelopeAuditLogFindData9(BaseModel):
    fields: List[EnvelopeAuditLogFindField1]


class DataDocumentFieldsAutoInsertedTypedDict(TypedDict):
    type: TypeDocumentFieldsAutoInserted
    data: EnvelopeAuditLogFindData9TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentFieldsAutoInserted(BaseModel):
    type: TypeDocumentFieldsAutoInserted

    data: EnvelopeAuditLogFindData9

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentDelegatedOwnerCreated(str, Enum):
    DOCUMENT_DELEGATED_OWNER_CREATED = "DOCUMENT_DELEGATED_OWNER_CREATED"


class EnvelopeAuditLogFindData8TypedDict(TypedDict):
    delegated_owner_name: Nullable[str]
    delegated_owner_email: str
    team_name: str


class EnvelopeAuditLogFindData8(BaseModel):
    delegated_owner_name: Annotated[
        Nullable[str], pydantic.Field(alias="delegatedOwnerName")
    ]

    delegated_owner_email: Annotated[str, pydantic.Field(alias="delegatedOwnerEmail")]

    team_name: Annotated[str, pydantic.Field(alias="teamName")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["delegatedOwnerName"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DataDocumentDelegatedOwnerCreatedTypedDict(TypedDict):
    type: TypeDocumentDelegatedOwnerCreated
    data: EnvelopeAuditLogFindData8TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentDelegatedOwnerCreated(BaseModel):
    type: TypeDocumentDelegatedOwnerCreated

    data: EnvelopeAuditLogFindData8

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentMovedToTeam(str, Enum):
    DOCUMENT_MOVED_TO_TEAM = "DOCUMENT_MOVED_TO_TEAM"


class EnvelopeAuditLogFindData7TypedDict(TypedDict):
    moved_by_user_id: float
    from_personal_account: bool
    to_team_id: float


class EnvelopeAuditLogFindData7(BaseModel):
    moved_by_user_id: Annotated[float, pydantic.Field(alias="movedByUserId")]

    from_personal_account: Annotated[bool, pydantic.Field(alias="fromPersonalAccount")]

    to_team_id: Annotated[float, pydantic.Field(alias="toTeamId")]


class DataDocumentMovedToTeamTypedDict(TypedDict):
    type: TypeDocumentMovedToTeam
    data: EnvelopeAuditLogFindData7TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentMovedToTeam(BaseModel):
    type: TypeDocumentMovedToTeam

    data: EnvelopeAuditLogFindData7

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentDeleted(str, Enum):
    DOCUMENT_DELETED = "DOCUMENT_DELETED"


class EnvelopeAuditLogFindTypeEnum(str, Enum):
    SOFT = "SOFT"
    HARD = "HARD"


class EnvelopeAuditLogFindData6TypedDict(TypedDict):
    type: EnvelopeAuditLogFindTypeEnum


class EnvelopeAuditLogFindData6(BaseModel):
    type: EnvelopeAuditLogFindTypeEnum


class DataDocumentDeletedTypedDict(TypedDict):
    type: TypeDocumentDeleted
    data: EnvelopeAuditLogFindData6TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentDeleted(BaseModel):
    type: TypeDocumentDeleted

    data: EnvelopeAuditLogFindData6

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentCreated(str, Enum):
    DOCUMENT_CREATED = "DOCUMENT_CREATED"


class TypeTemplateDirectLink(str, Enum):
    TEMPLATE_DIRECT_LINK = "TEMPLATE_DIRECT_LINK"


class SourceTemplateDirectLinkTypedDict(TypedDict):
    type: TypeTemplateDirectLink
    template_id: float
    direct_recipient_email: str


class SourceTemplateDirectLink(BaseModel):
    type: TypeTemplateDirectLink

    template_id: Annotated[float, pydantic.Field(alias="templateId")]

    direct_recipient_email: Annotated[str, pydantic.Field(alias="directRecipientEmail")]


class SourceTypeTemplate(str, Enum):
    TEMPLATE = "TEMPLATE"


class SourceTemplateTypedDict(TypedDict):
    type: SourceTypeTemplate
    template_id: float


class SourceTemplate(BaseModel):
    type: SourceTypeTemplate

    template_id: Annotated[float, pydantic.Field(alias="templateId")]


class TypeDocument(str, Enum):
    DOCUMENT = "DOCUMENT"


class EnvelopeAuditLogFindSourceDocumentTypedDict(TypedDict):
    type: TypeDocument


class EnvelopeAuditLogFindSourceDocument(BaseModel):
    type: TypeDocument


SourceTypedDict = TypeAliasType(
    "SourceTypedDict",
    Union[
        EnvelopeAuditLogFindSourceDocumentTypedDict,
        SourceTemplateTypedDict,
        SourceTemplateDirectLinkTypedDict,
    ],
)


Source = Annotated[
    Union[
        Annotated[EnvelopeAuditLogFindSourceDocument, Tag("DOCUMENT")],
        Annotated[SourceTemplate, Tag("TEMPLATE")],
        Annotated[SourceTemplateDirectLink, Tag("TEMPLATE_DIRECT_LINK")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class EnvelopeAuditLogFindData5TypedDict(TypedDict):
    title: str
    source: NotRequired[SourceTypedDict]


class EnvelopeAuditLogFindData5(BaseModel):
    title: str

    source: Optional[Source] = None


class DataDocumentCreatedTypedDict(TypedDict):
    type: TypeDocumentCreated
    data: EnvelopeAuditLogFindData5TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentCreated(BaseModel):
    type: TypeDocumentCreated

    data: EnvelopeAuditLogFindData5

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeDocumentCompleted(str, Enum):
    DOCUMENT_COMPLETED = "DOCUMENT_COMPLETED"


class EnvelopeAuditLogFindData4TypedDict(TypedDict):
    transaction_id: str


class EnvelopeAuditLogFindData4(BaseModel):
    transaction_id: Annotated[str, pydantic.Field(alias="transactionId")]


class DataDocumentCompletedTypedDict(TypedDict):
    type: TypeDocumentCompleted
    data: EnvelopeAuditLogFindData4TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataDocumentCompleted(BaseModel):
    type: TypeDocumentCompleted

    data: EnvelopeAuditLogFindData4

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeEmailSent(str, Enum):
    EMAIL_SENT = "EMAIL_SENT"


class EmailType(str, Enum):
    SIGNING_REQUEST = "SIGNING_REQUEST"
    VIEW_REQUEST = "VIEW_REQUEST"
    APPROVE_REQUEST = "APPROVE_REQUEST"
    ASSISTING_REQUEST = "ASSISTING_REQUEST"
    CC = "CC"
    DOCUMENT_COMPLETED = "DOCUMENT_COMPLETED"


class EnvelopeAuditLogFindData3TypedDict(TypedDict):
    recipient_email: str
    recipient_name: str
    recipient_id: float
    recipient_role: str
    email_type: EmailType
    is_resending: bool


class EnvelopeAuditLogFindData3(BaseModel):
    recipient_email: Annotated[str, pydantic.Field(alias="recipientEmail")]

    recipient_name: Annotated[str, pydantic.Field(alias="recipientName")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    recipient_role: Annotated[str, pydantic.Field(alias="recipientRole")]

    email_type: Annotated[EmailType, pydantic.Field(alias="emailType")]

    is_resending: Annotated[bool, pydantic.Field(alias="isResending")]


class DataEmailSentTypedDict(TypedDict):
    type: TypeEmailSent
    data: EnvelopeAuditLogFindData3TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataEmailSent(BaseModel):
    type: TypeEmailSent

    data: EnvelopeAuditLogFindData3

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeEnvelopeItemDeleted(str, Enum):
    ENVELOPE_ITEM_DELETED = "ENVELOPE_ITEM_DELETED"


class EnvelopeAuditLogFindData2TypedDict(TypedDict):
    envelope_item_id: str
    envelope_item_title: str


class EnvelopeAuditLogFindData2(BaseModel):
    envelope_item_id: Annotated[str, pydantic.Field(alias="envelopeItemId")]

    envelope_item_title: Annotated[str, pydantic.Field(alias="envelopeItemTitle")]


class DataEnvelopeItemDeletedTypedDict(TypedDict):
    type: TypeEnvelopeItemDeleted
    data: EnvelopeAuditLogFindData2TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataEnvelopeItemDeleted(BaseModel):
    type: TypeEnvelopeItemDeleted

    data: EnvelopeAuditLogFindData2

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TypeEnvelopeItemCreated(str, Enum):
    ENVELOPE_ITEM_CREATED = "ENVELOPE_ITEM_CREATED"


class EnvelopeAuditLogFindData1TypedDict(TypedDict):
    envelope_item_id: str
    envelope_item_title: str


class EnvelopeAuditLogFindData1(BaseModel):
    envelope_item_id: Annotated[str, pydantic.Field(alias="envelopeItemId")]

    envelope_item_title: Annotated[str, pydantic.Field(alias="envelopeItemTitle")]


class DataEnvelopeItemCreatedTypedDict(TypedDict):
    type: TypeEnvelopeItemCreated
    data: EnvelopeAuditLogFindData1TypedDict
    id: str
    created_at: str
    envelope_id: str
    name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    user_id: NotRequired[Nullable[float]]
    user_agent: NotRequired[Nullable[str]]
    ip_address: NotRequired[Nullable[str]]


class DataEnvelopeItemCreated(BaseModel):
    type: TypeEnvelopeItemCreated

    data: EnvelopeAuditLogFindData1

    id: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    name: OptionalNullable[str] = UNSET

    email: OptionalNullable[str] = UNSET

    user_id: Annotated[OptionalNullable[float], pydantic.Field(alias="userId")] = UNSET

    user_agent: Annotated[OptionalNullable[str], pydantic.Field(alias="userAgent")] = (
        UNSET
    )

    ip_address: Annotated[OptionalNullable[str], pydantic.Field(alias="ipAddress")] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        nullable_fields = ["name", "email", "userId", "userAgent", "ipAddress"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


EnvelopeAuditLogFindDataUnionTypedDict = TypeAliasType(
    "EnvelopeAuditLogFindDataUnionTypedDict",
    Union[
        DataEnvelopeItemCreatedTypedDict,
        DataEnvelopeItemDeletedTypedDict,
        DataEmailSentTypedDict,
        DataDocumentCompletedTypedDict,
        DataDocumentCreatedTypedDict,
        DataDocumentDeletedTypedDict,
        DataDocumentMovedToTeamTypedDict,
        DataDocumentDelegatedOwnerCreatedTypedDict,
        DataDocumentFieldsAutoInsertedTypedDict,
        DataDocumentFieldInsertedTypedDict,
        DataDocumentFieldUninsertedTypedDict,
        DataDocumentFieldPrefilledTypedDict,
        DataDocumentVisibilityUpdatedTypedDict,
        DataDocumentGlobalAuthAccessUpdatedTypedDict,
        DataDocumentGlobalAuthActionUpdatedTypedDict,
        DataDocumentMetaUpdatedTypedDict,
        DataDocumentOpenedTypedDict,
        DataDocumentViewedTypedDict,
        DataDocumentRecipientCompletedTypedDict,
        DataDocumentRecipientRejectedTypedDict,
        DataDocumentAccessAuth2FaRequestedTypedDict,
        DataDocumentAccessAuth2FaValidatedTypedDict,
        DataDocumentAccessAuth2FaFailedTypedDict,
        DataDocumentSentTypedDict,
        DataDocumentTitleUpdatedTypedDict,
        DataDocumentExternalIDUpdatedTypedDict,
        DataFieldCreatedTypedDict,
        DataFieldDeletedTypedDict,
        DataFieldUpdatedTypedDict,
        DataRecipientCreatedTypedDict,
        DataRecipientUpdatedTypedDict,
        DataRecipientDeletedTypedDict,
    ],
)


EnvelopeAuditLogFindDataUnion = Annotated[
    Union[
        Annotated[DataEnvelopeItemCreated, Tag("ENVELOPE_ITEM_CREATED")],
        Annotated[DataEnvelopeItemDeleted, Tag("ENVELOPE_ITEM_DELETED")],
        Annotated[DataEmailSent, Tag("EMAIL_SENT")],
        Annotated[DataDocumentCompleted, Tag("DOCUMENT_COMPLETED")],
        Annotated[DataDocumentCreated, Tag("DOCUMENT_CREATED")],
        Annotated[DataDocumentDeleted, Tag("DOCUMENT_DELETED")],
        Annotated[DataDocumentMovedToTeam, Tag("DOCUMENT_MOVED_TO_TEAM")],
        Annotated[
            DataDocumentDelegatedOwnerCreated, Tag("DOCUMENT_DELEGATED_OWNER_CREATED")
        ],
        Annotated[DataDocumentFieldsAutoInserted, Tag("DOCUMENT_FIELDS_AUTO_INSERTED")],
        Annotated[DataDocumentFieldInserted, Tag("DOCUMENT_FIELD_INSERTED")],
        Annotated[DataDocumentFieldUninserted, Tag("DOCUMENT_FIELD_UNINSERTED")],
        Annotated[DataDocumentFieldPrefilled, Tag("DOCUMENT_FIELD_PREFILLED")],
        Annotated[DataDocumentVisibilityUpdated, Tag("DOCUMENT_VISIBILITY_UPDATED")],
        Annotated[
            DataDocumentGlobalAuthAccessUpdated,
            Tag("DOCUMENT_GLOBAL_AUTH_ACCESS_UPDATED"),
        ],
        Annotated[
            DataDocumentGlobalAuthActionUpdated,
            Tag("DOCUMENT_GLOBAL_AUTH_ACTION_UPDATED"),
        ],
        Annotated[DataDocumentMetaUpdated, Tag("DOCUMENT_META_UPDATED")],
        Annotated[DataDocumentOpened, Tag("DOCUMENT_OPENED")],
        Annotated[DataDocumentViewed, Tag("DOCUMENT_VIEWED")],
        Annotated[DataDocumentRecipientCompleted, Tag("DOCUMENT_RECIPIENT_COMPLETED")],
        Annotated[DataDocumentRecipientRejected, Tag("DOCUMENT_RECIPIENT_REJECTED")],
        Annotated[
            DataDocumentAccessAuth2FaRequested,
            Tag("DOCUMENT_ACCESS_AUTH_2FA_REQUESTED"),
        ],
        Annotated[
            DataDocumentAccessAuth2FaValidated,
            Tag("DOCUMENT_ACCESS_AUTH_2FA_VALIDATED"),
        ],
        Annotated[
            DataDocumentAccessAuth2FaFailed, Tag("DOCUMENT_ACCESS_AUTH_2FA_FAILED")
        ],
        Annotated[DataDocumentSent, Tag("DOCUMENT_SENT")],
        Annotated[DataDocumentTitleUpdated, Tag("DOCUMENT_TITLE_UPDATED")],
        Annotated[DataDocumentExternalIDUpdated, Tag("DOCUMENT_EXTERNAL_ID_UPDATED")],
        Annotated[DataFieldCreated, Tag("FIELD_CREATED")],
        Annotated[DataFieldDeleted, Tag("FIELD_DELETED")],
        Annotated[DataFieldUpdated, Tag("FIELD_UPDATED")],
        Annotated[DataRecipientCreated, Tag("RECIPIENT_CREATED")],
        Annotated[DataRecipientUpdated, Tag("RECIPIENT_UPDATED")],
        Annotated[DataRecipientDeleted, Tag("RECIPIENT_DELETED")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class EnvelopeAuditLogFindResponseTypedDict(TypedDict):
    r"""Successful response"""

    data: List[EnvelopeAuditLogFindDataUnionTypedDict]
    count: float
    current_page: float
    per_page: float
    total_pages: float


class EnvelopeAuditLogFindResponse(BaseModel):
    r"""Successful response"""

    data: List[EnvelopeAuditLogFindDataUnion]

    count: float

    current_page: Annotated[float, pydantic.Field(alias="currentPage")]

    per_page: Annotated[float, pydantic.Field(alias="perPage")]

    total_pages: Annotated[float, pydantic.Field(alias="totalPages")]
